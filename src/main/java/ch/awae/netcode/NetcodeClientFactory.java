package ch.awae.netcode;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Getter;

import javax.net.SocketFactory;
import java.io.IOException;
import java.net.Socket;
import java.util.Objects;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Factory for creating Netcode clients.
 * 
 * By default clients are created in synchronous mode.
 * 
 * Every client provides an application id to the Netcode server. This
 * application id is used to ensure that only compatible clients join a single
 * channel. The server may also choose to accept only certain application ids.
 * 
 * Most methods return the object itself to allow easy method chaining.
 * 
 * @since netcode 0.1.0
 * @author Andreas WÃ¤lchli
 * @see NetcodeClient
 */
@Getter
@AllArgsConstructor(access = AccessLevel.PRIVATE)
public final class NetcodeClientFactory {

	private MessageHandler messageHandler;
	private ChannelEventHandler eventHandler;
	private ClientQuestionHandler questionHandler;
	private long timeout = 60000;

	private final String appId;
	private final String host;
	private final int port;

	/**
	 * Creates a new factory with the given host and port information and appId.
	 * 
	 * @param host  the server address. may not be null.
	 * @param port  the port number of the server. must be in the range 0-65535.
	 * @param appId the application id to use for this client. may not be null.
	 */
	public NetcodeClientFactory(String host, int port, String appId) {
		Objects.requireNonNull(host);
		Objects.requireNonNull(appId);
		if (port < 0 || port > 65535)
			throw new IllegalArgumentException("port " + port + " is outside the legal range (0-65535)");
		this.host = host;
		this.port = port;
		this.appId = appId;
	}

	/**
	 * Creates a new Netcode channel. This does not consume this factory and it can
	 * therefore be re-used.
	 * 
	 * @param userId        the userId for this client. may not be null.
	 * @param configuration the channel configuration to use.
	 * @return an initialised client instance.
	 * @throws IOException         an exception occured in the unterlying I/O
	 *                             elements.
	 * @throws ConnectionException a netcode connection could not be established.
	 *                             Usually this indicates that some client data was
	 *                             rejected by the server. See the exception type
	 *                             and message for more information.
	 */
	public NetcodeClient createChannel(String userId, ChannelConfiguration configuration)
			throws IOException, ConnectionException {
		Objects.requireNonNull(userId);
		Objects.requireNonNull(configuration);
		if (userId.isEmpty())
			throw new IllegalArgumentException("userId may not be empty");
		NetcodeClientImpl client = initSocket();
		client.open(new NetcodeHandshakeRequest(appId, null, userId, true, configuration));
		return client;
	}

	/**
	 * Joins an existing Netcode channel. This does not consume this factory and it
	 * can therefore be re-used.
	 * 
	 * @param userId    the userId for this client. may not be null.
	 * @param channelId the id of the channel to join. Channel IDs are generated by
	 *                  the server upon channel generation.
	 * @return an initialised client instance.
	 * @throws IOException         an exception occured in the unterlying I/O
	 *                             elements.
	 * @throws ConnectionException a netcode connection could not be established.
	 *                             Usually this indicates that some client data was
	 *                             rejected by the server. See the exception type
	 *                             and message for more information.
	 */
	public NetcodeClient joinChannel(String userId, String channelId) throws IOException, ConnectionException {
		Objects.requireNonNull(userId);
		Objects.requireNonNull(channelId);
		if (userId.isEmpty())
			throw new IllegalArgumentException("userId may not be empty");
		NetcodeClientImpl client = initSocket();
		client.open(new NetcodeHandshakeRequest(appId, channelId, userId, false, null));
		return client;
	}

	/**
	 * get a list of all public Netcode channels with at least one free slot.
	 * 
	 * @since netcode 2.0.0
	 * @throws IOException
	 * @throws ConnectionException if the server does not support SIMPLE_QUERY (v1
	 *                             servers) or the server has disabled public
	 *                             channels (v2 servers and above)
	 */
	public ChannelInformation[] listPublicChannels() throws IOException, ConnectionException {
		NetcodeClientImpl client = initSocket();
		return (ChannelInformation[]) client.simpleQuery("channel_list:" + appId);
	}

	private NetcodeClientImpl initSocket() throws IOException {
		SocketFactory sf = SocketFactory.getDefault();
		Socket s = sf.createSocket(this.host, this.port);
		s.setKeepAlive(true);
		ExecutorService threadPool = createThreadPool();
		return new NetcodeClientImpl(s, messageHandler, eventHandler, questionHandler, timeout, threadPool);
	}

	private ExecutorService createThreadPool() {
		// TODO: make configurable
		return Executors.newCachedThreadPool();
	}

	/**
	 * Sets a new timeout value to be used for server commands and client questions.
	 * If this is set to 0, the timeout is disabled.
	 * 
	 * @param timeout the new timeout in milliseconds
	 * @throws IllegalArgumentException the timeout is negative
	 * @see NetcodeClient#ask(String, java.io.Serializable)
	 */
	public NetcodeClientFactory setTimeout(long timeout) {
		if (timeout < 0)
			throw new IllegalArgumentException("Timeout may not be negative!");
		this.timeout = timeout;
		return this;
	}

	public NetcodeClientFactory setMessageHandler(MessageHandler messageHandler) {
		this.messageHandler = messageHandler;
		return this;
	}

	public NetcodeClientFactory setEventHandler(ChannelEventHandler eventHandler) {
		this.eventHandler = eventHandler;
		return this;
	}

	public NetcodeClientFactory setQuestionHandler(ClientQuestionHandler questionHandler) {
		this.questionHandler = questionHandler;
		return this;
	}

	public NetcodeClientFactory copy() {
		return new NetcodeClientFactory(messageHandler, eventHandler, questionHandler, timeout, appId, host, port);
	}

}
